import yaml
import sys
import math

def total_steps(cfg):
    angle = cfg["stepper_angle"]
    microstep = cfg["microstep"]
    gear_big = cfg["gear_big"]
    gear_small = cfg["gear_small"]
    worm = cfg["worm_reduction"]
    steps = 360.0 / angle * microstep * gear_big / gear_small * worm
    assert(abs(steps - round(steps)) < 1e-3)
    return round(steps)

def reduce(a, b):
    k = math.gcd(a, b)
    return (a//k, b//k)

def calculate_goto(fcpu, ha_steps_per_sec, dec_steps_per_sec):
    psc = 64
    psc0 = 1
    psc1 = 1
    psc2 = 0
    counter_ha  = int(fcpu / psc / ha_steps_per_sec)
    counter_dec = int(fcpu / psc / dec_steps_per_sec)
    return counter_ha, counter_dec, psc0, psc1, psc2

def calculate_rotate_ha(fcpu, ha_total_steps, ha_total_seconds, subseconds):
    psc = 1024
    psc0 = 1
    psc1 = 0
    psc2 = 1 
    base_delay = int(3600 * ha_total_seconds * subseconds * fcpu / psc / ha_total_steps)
    return base_delay, psc0, psc1, psc2

def calculate_rotate_dec(fcpu, dec_total_steps, dec_total_seconds, subseconds):
    psc = 1024
    divisor = 64
    psc0 = 1
    psc1 = 0
    psc2 = 1
    base_delay = int(3600 * dec_total_seconds * subseconds * fcpu / psc / dec_total_steps)
    return base_delay, divisor, psc0, psc1, psc2

template = """
// This is autogenerated file. Don't edit!
#pragma once

#define F_CPU         {fcpu}UL

#define HA_STEPS      {ha_total_steps}UL
#define HA_2_STEPS_A  {ha_a}L
#define HA_2_STEPS_B  {ha_b}L

#define DEC_STEPS     {dec_total_steps}UL
#define DEC_2_STEPS_A {dec_a}L
#define DEC_2_STEPS_B {dec_b}L

#define SUBSECONDS    {subseconds}

#define BAUD {baud}

#define GOTO_TIMER_COUNTER_HA {g_counter_ha}
#define GOTO_TIMER_COUNTER_DEC {g_counter_dec}
#define GOTO_PSC0 {g_psc0}
#define GOTO_PSC1 {g_psc1}
#define GOTO_PSC2 {g_psc2}

#define ROTATION_BASE_DELAY_HA  {r_base_delay_ha}UL
#define ROTATION_PSC0_HA        {r_psc0_ha}
#define ROTATION_PSC1_HA        {r_psc1_ha}
#define ROTATION_PSC2_HA        {r_psc2_ha}

#define ROTATION_BASE_DELAY_DEC {r_base_delay_dec}UL
#define ROTATION_DIVISOR_DEC    {r_divisor_dec}
#define ROTATION_PSC0_DEC       {r_psc0_dec}
#define ROTATION_PSC1_DEC       {r_psc1_dec}
#define ROTATION_PSC2_DEC       {r_psc2_dec}


"""


with open(sys.argv[1]) as f:
    cfg = yaml.load(f)

args={}

args["baud"]=cfg["system"]["baud"]
args["fcpu"]=cfg["system"]["fcpu"]

dec_total_seconds = 360 * 60 * 60
args["dec_total_steps"] = total_steps(cfg["config"]["dec"])
args["dec_a"], args["dec_b"] = reduce(args["dec_total_steps"], dec_total_seconds)

ha_total_seconds = 24 * 60 * 60
args["ha_total_steps"]  = total_steps(cfg["config"]["ha"])
args["ha_a"], args["ha_b"] = reduce(args["ha_total_steps"], ha_total_seconds)


# GOTO config
args["rotation_time"] = cfg["movement"]["full_rotation_time"]
ha_steps_per_second = int(args["ha_total_steps"] / args["rotation_time"])
dec_steps_per_second = int(args["dec_total_steps"] / args["rotation_time"])
args["g_counter_ha"], args["g_counter_dec"], args["g_psc0"], args["g_psc1"], args["g_psc2"] = calculate_goto(args["fcpu"], ha_steps_per_second, dec_steps_per_second)

# ROTATION config
args["subseconds"] = cfg["movement"]["subseconds"]
args["r_base_delay_ha"], args["r_psc0_ha"], args["r_psc1_ha"], args["r_psc2_ha"] = \
                calculate_rotate_ha(args["fcpu"], args["ha_total_steps"], ha_total_seconds, args["subseconds"])

args["r_base_delay_dec"], args["r_divisor_dec"], args["r_psc0_dec"], args["r_psc1_dec"], args["r_psc2_dec"] = \
                calculate_rotate_dec(args["fcpu"], args["dec_total_steps"], dec_total_seconds, args["subseconds"])

res = template.format(**args)

with open(sys.argv[2], "w") as f:
    f.write(res)

